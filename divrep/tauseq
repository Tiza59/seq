#!/opt/maths/bin/perl -w
use strict;
BEGIN { $Math::Pari::initmem=1e8; $Math::Pari::initprimes=1e8 }
use Math::Pari qw/ PARI factorint isprime prime gcd Mod lift divrem pari2iv /;

use lib './clib';
use Constraint;
use ModFunc qw/ mod_combine quadvec /;

my($opt_n, $opt_x, $opt_c, $opt_t, $opt_cp, $opt_cr)
		= (0, 0, 0, 100000, 0, 0);
my $new_check = 0;
while (@ARGV && $ARGV[0] =~ /^-/) {
	my $arg = shift @ARGV;
	last if $arg eq '--';
	Constraint->debug_more(), next if $arg eq '-d';
$new_check = 1, next if $arg eq '-nc';
	($opt_n = $arg || shift(@ARGV)), next if $arg =~ s{^-n}{};
	($opt_x = $arg || shift(@ARGV)), next if $arg =~ s{^-x}{};
	($opt_cp = $arg || shift(@ARGV)), next if $arg =~ s{^-cp}{};
	($opt_cr = $arg || shift(@ARGV)), next if $arg =~ s{^-cr}{};
	($opt_c = $arg || shift(@ARGV)), next if $arg =~ s{^-c}{};
	($opt_t = $arg || shift(@ARGV)), next if $arg =~ s{^-t}{};
	die "Unknown option '$arg'\n";
}

$| = 1;
my($n, $f) = map PARI($_), @ARGV;
my $tn = tau($n);
my $c = Constraint->new(
	'n' => $n,
	'f' => $f,
	'tell_count' => $opt_t,
	't0' => scalar times(),
	'min' => $opt_n,
	'max' => $opt_x,
	'check' => $opt_c,
	'min_potency' => $opt_cr,
	'tau' => $tn,
);

$c = apply($c) or exit 0;
printf <<OUT, $c->elapsed(), 'rootseq', $n, $f, $opt_n, $opt_x, $opt_c;
300 Init %.2f: trying %s() for (%s, %s) in [%s, %s], checks up to mod %s
OUT

my $d = rootseq($c);
if ($d) {
	report_seq($n, $f, $d);
	printf <<OUT, $n, $f, $d, $c->elapsed();
200 f(%s, %s) = %s  (%.3fs)
OUT
} else {
	printf <<OUT, $n, $f, $opt_x, $c->elapsed();
500 f(%s, %s) > %s  (%.3fs)
OUT
}
exit 0;

sub apply {
	my $c = shift;
	my $tn = $c->tau;

	for my $m (2 .. $c->check) {
$c->debug && warn "apply $m\n";
		my $fm = factorint($m);
		next if $opt_cp && $fm->[0][$#{ $fm->[0] }] > $opt_cp;

		#
		# If n is prime, the only thing we can usefully do is avoid primes
		#
		if ($tn == 2) {
			series($c, 0, $m, $m) if @{ $fm->[0] } == 1 && $fm->[1][0] == 1;
			next;
		}

		#
		# If we know n+kd must not divide m (maybe only beyond some maximum
		# value for n+kd), use that to deny various values (mod m).
		#
		my $max = test_series($m, $tn);
		series($c, 0, $m, $max) if $max >= 0;

if ($new_check) {
		#
		# Look for restrictions on quadratic non-residues mod some factors
		# of m, when prime powers fixed by other factors leave us needing
		# a square.
		#
		quadres_series($c, $m, $tn);
} else {
		#
		# If setting n+kd == a (mod b) fixes some divisors so that others
		# must be square, use that to deny quadratic non-residues.
		#
		my $iter = iter_quadres_series($m, $tn);
		while (my $result = $iter->()) {
			my($mod_quad, $value_fixed, $mod_fixed, $max) = @$result;
			square_series($c, $mod_quad, $value_fixed, $mod_fixed, $max);
		}
}

		#
		# n+kd == m (mod m rad(m)) is suppressible when tau(m) ~| tau(n)
		#
		test_m_rad_m($c, $m, $fm);
	}

	#
	# If we know n+kd fixes all but a square for some k, that's a hugely
	# powerful optimisation. Applicability depends on other constraints,
	# so we check for this last.
	#
	# TODO: Check if pending constraints would trigger this optimisation,
	# and schedule it if so.
	#
	my $fix_square = fix_square($c, $n, $tn);
	if ($fix_square) {
		my($k, $ty2) = @$fix_square;
		# we require d = y^2 - n/k, with tau(y^2) = ty2
		warn "311 Fixing square d = y^2 - n/$k, tau(y^2) = $ty2\n";
		$c = $c->fix_square($k, $ty2);
	}

	return $c;
}

#
# disallow n+kd=v (mod m) for n+kd > max
#
sub series {
	my($c, $v, $m, $max) = @_;
	$max ||= 0;
	($c->debug > 1) && warn "series ($v, $m, $max)\n";
	my $n = $c->n;
	for my $k (1 .. $c->f - 1) {
		my $g = gcd($k, $m);
		my($gv, $gvr) = @{ divrem($v - $n, $g) };
		next if $gvr != 0;	# No constraint: this modval can't happen
		my $m2 = $m / $g;
		my $v2 = lift(Mod($gv, $m2) / ($k / $g));
		$c->suppress($m2, $v2, int(($max - $n) / $k) + 1);
	}
	($c->debug > 1) && warn "series ($v, $m, $max): applied\n";
}

#
# Disallow n+kd == w gcd(y,z) (mod x) and y(mod z)
# whenever w is a non-residue (mod x) and n+kd > max.
#
sub square_series {
	my($c, $x, $y, $z, $max) = @_;
	$max ||= 0;
	($c->debug > 1) && warn "square_series ($x, $y, $z, $max)\n";
	my $quadx = quadvec($x);
	my $yz = gcd($y, $z);
	my($v, $m);
	for my $w (0 .. $x - 1) {
		next if vec($quadx, $w, 1);	# w is not a non-residue
		($v, $m) = mod_combine($w * $yz, $x, $y, $z);
		series($c, $v, $m, $max);
	}
	($c->debug > 1) && warn "square_series ($x, $y, $z, $max): applied\n";
}

#
# To fix d to be related to a square, we need to find x such that:
# 1) f > x
# 2) x.rad(x) | n
# 3) gcd(x, d) = 1 by prior constraints
# 4) tau(n) = (2y + 1)tau(x) for some y
# Then we know n+xd = xy^2 for some y (and we know tau(y)).
#
sub fix_square {
	my($c, $n, $tn) = @_;
	my $f = $c->f();
	my $debug = $c->debug;
	for my $x (@{ $n->divisors }) {
		last if $x >= $f;	# divisors are returned in ascending order
		my $fx = factorint($x);
		my $rx = rad_factor($fx);
		$debug && warn("Would try fix_square($x), but 0(mod $rx) is not disallowed.\n"),
		next unless $c->disallowed($rx, 0);
		my $xrx = $x * $rx;
		$debug && warn("Would try fix_square($x), but $xrx does not divide $n.\n"),
		next if gcd($xrx, $n) < $xrx;
		my $tx = tau_factor($fx);
		my($tdiv, $trem) = @{ divrem($tn, $tx) };
		$debug && warn("Would try fix_square($x), but tau($x) does not divide $tn.\n"),
		next if $trem;
		$debug && warn("Would try fix_square($x), but $tn/tau($x) is even.\n"),
		next if !($tdiv & 1);
		$debug && warn("Will fix_square($x).\n"),
		return [$x, $tdiv];
	}
	return undef;
}

#
# If \tau(n) / \tau(m) is odd, n + kd == vm (mod m rad m), gcd(v, rad m) = 1
# then we can suppress vm (mod m rad m) unless v is a quadratic residue
# mod each prime p dividing m, and we can suppress vm (mod q m rad m) unless
# v is a quadratic residue mod q.
# We can go further if instead of q we take q^s: when s is even we have
# additional non-residues uq^{s-1} (0 < u < q), and when s is odd we have
# additional uq^{s-1} (u any non-residue mod q). But doing so requires
# multiple passes over the factors.
#
sub quadres_series {
	my($c, $pmr, $tn) = @_;
	my $debug = $c->debug;
	$debug > 1 && print "qs: try $pmr\n";
	my($mp, $mrpp) = @{ factorint($pmr) };
	my($spare, $p);
	my $mpp = [ map {
		my $pp = $mrpp->[$_] - 1;
		if ($pp == 0) {
			if (defined $spare) {
				# only one spare allowed
				$debug > 2 && print "qs: too many spares ($mp->[$spare] and $mp->[$_]), skip\n";
				return;
			}
			$spare = $_;
		}
		$pp
	} 0 .. $#$mp ];
	my $mr = $pmr;
	if (defined $spare) {
		$p = $mp->[$spare];
		$mr /= $p;
		# PARI-generated arrayrefs don't support splice
		$mp = [@$mp]; splice @$mp, $spare, 1;
		$mrpp = [@$mrpp]; splice @$mrpp, $spare, 1;
		splice @$mpp, $spare, 1;
	}
	my $tm = tau_factor([ undef, $mpp ]);
	my($div, $rem) = @{ divrem($tn, $tm) };
	if ($rem) {
		$debug > 2 && print "qs: tm does not divide tn, skip\n";
		return;
	}
	if (! ($div & 1)) {
		$debug > 2 && print "qs: tn / tm is even, skip\n";
		return;
	}
	$debug > 2 && print "qs: ok\n";
	my $m = unfactorint([ $mp, $mpp ]);
	my $r = $mr / $m;

	# The conditions apply, now either:
	# if p:
	#   v not a quadres (mod p) for vm (mod m rad m), (v, m) = 1
	# else:
	#   v not a quadres (mod rad m) for vm (mod m rad m), (v, m) = 1

	if ($p) {
		my $vp = quadvec($p);
		$debug > 2 && print "qs: p=$p\n";
		VP: for my $v (1 .. $r * $p - 1) {
			next if gcd($v, $r) > 1;
			my $md = pari2iv($v % $p);
			next if vec($vp, $md, 1);	# it's a residue mod p
			my $mv = $m * $v;
			$debug > 2 && print "qs: series $v * $m, $pmr\n";
			series($c, $mv, $pmr, 0);
		}
	} else {
		my @vm = map quadvec($_), @$mp;
		$debug > 2 && print "qs: no spare\n";
		V: for my $v (1 .. $r - 1) {
			next if gcd($v, $r) > 1;
			my $nonresidue = 0;
			for (0 .. $#$mp) {
				my $md = pari2iv($v % $mp->[$_]);
				$nonresidue = 1, last unless vec($vm[$_], $md, 1);
			}
			next unless $nonresidue;
			$debug > 2 && print "qs: series $v * $m, $pmr\n";
			series($c, $v * $m, $pmr, 0);
		}
	}
}

#
# Let m_4=\prod{p_i^d_i}, d_i < a_i, and 
# q_4 = \prod{p_i: p_i | m, p_i ~| m4 } > 1.
# 
# Then any way to select m_4, q_4: tau(n) / tau(m_4) = 2k+1 gives
# gcd(n+kd, m)=m_4 -> n+kd must be a quadratic residue (mod q_4).
# 
# FIXME: for n=243, k >= 3, at m = 9 (or maybe 27) this should see that
# n+d = 3p^2, n+2d = 3q^2, n+3d = 3^2r between them deny all multiples
# of 3, which would then allow fix_square(3). I guess this is because
# we require gcd(m_4, q_4) = 1, but here we need m_4 = q_4 = 3.
# It's possible we disallow that because we rely on selecting a complete
# prime power out of m: we should consider also selecting all but one.
#
# FIXME: I think we restrict gcd(m_4, q_4) = 1 to reduce the number of
# combinations to consider; but I suspect we could get a far more
# effective restriction by considering only q_4 prime - if m_4 pq
# qualifies, won't that only make the same quadres restrictions we've
# already 
#
sub iter_quadres_series {
	my($m, $tn) = @_; 
	my $fm = factorint($m);
	my $p = $fm->[0];

	# To search for this, we need 2^k | tau(n) -> 2^k | tau(m_4).
	my $tnpow2 = maxpow2mult($tn);
# FIXME: shouldn't this be maxpow2arith($_ + 1)?
	my @tmpow2 = map maxpow2arith($_), @{ $fm->[1] };

	# We require q_4 > 1, so the greatest power of 2 we can account for
	# is sum(tmpow2) - min(tmpow2).
	my $sumpow2 = sum(\@tmpow2);
	my $minpow2 = min(\@tmpow2);
	return sub { return undef } if $sumpow2 - $minpow2 < $tnpow2;

	# Internally we'll iterate to find each valid way to fix some prime powers.
	my $iter = iter_square_kernel_assignment($tn, $fm->[1], 0);
	# For each assignment, we'll loop k to try each value (mod m4_fixed_mult)
	# that honours the assigment. Set k to undef to signal that we need a new
	# assignment.
	my $k = undef;
	my($assignment, $m4_fixed_mult, $m4_quad, $m4_mult, $m4_avoid_mult);
	return sub {
		while (1) {
			if (defined $k) {
				++$k;
				if ($k >= $m4_avoid_mult) {
					$k = undef;
				} else {
					next if gcd($k, $m4_avoid_mult) > 1;
					my $mod = $k *  $m4_fixed_mult;
					return [ $m4_quad, $mod, $m4_mult, 0 ];
				}
			}
			$assignment = $iter->() or return undef;
			$m4_fixed_mult = 1;
			$m4_quad = 1;
			for my $i (0 .. $#$p) {
				if ($assignment->[$i] == 0) {
					$m4_quad *= $p->[$i] ** $fm->[1][$i];
					next;
				}
				$m4_fixed_mult *= $p->[$i] ** $assignment->[$i];
			}
			$m4_mult = $m / $m4_quad;
			$m4_avoid_mult = $m4_mult / $m4_fixed_mult;
			$k = 0;
		}
	};
}

sub test_series {
	my($m, $tn) = @_;
	my $fm = factorint($m);
	my $tm = tau_factor($fm);
	my $p = $fm->[0];
	my $max = -1;

	#
	# If tau(m) >= tau(n) we can limit the options (mod m).
	#
	if ($tm > $tn) {
		return 0;
	} elsif ($tm == $tn) {
		$max = $m;
	}

	#
	# Let m=\prod{p_i^a_i}, m_2=\prod{p_i^b_i} where b_i is least k >= a_i
	# such that b_i + 1 divides tau(n). Then if tau(m_2) >= tau(n) we can
	# limit the options (mod m) for n+kd > m_2.
	# 
	my $fm2 = [ $p, [ map first_divisor($tn, $_ + 1) - 1, @{ $fm->[1] } ] ];
	my $m2 = unfactorint($fm2);
	my $tm2 = tau_factor($fm2);
	if ($m2 > $m) {
		if ($tm2 > $tn) {
			return 0;
		} elsif ($tm2 == $tn) {
			$max = $m2 unless $max >= 0 && $max < $m2;
		}
	}

	#
	# Let m_3=\prod{p_i^c_i}, c^i>=b_i. Valid solutions require selecting
	# k_j, m_{3j} such that tau(k_j m_{3j})=tau(n). If k_j=1 for all j,
	# we can limit the options (mod m) for n+kd > max(m_{3j}).
	#
	if (gcd($tm2, $tn) < $tm2) {
		my $maxm3 = 0;
		my $good = 1;
		my $iter = iter_factor($tn);
		while (my $tn_factors = $iter->()) {
			my $fm3 = [ $p, [ map $_ - 1, @$tn_factors ] ];
			next if @{ $fm3->[1] } < @{ $fm2->[1] };
			next if grep $fm3->[1][$_] < $fm2->[1][$_], 0 .. $#$p;
			$good = 0, last if @$tn_factors > @$p;
			my $m3 = unfactorint($fm3);
			$maxm3 = $m3 if $maxm3 < $m3;
		}
		$max = $maxm3 if $good && !($max >= 0 && $max < $maxm3);
	}
	return $max;
}

#
# Given target product t, source list s, boolean fixed, return an iterator
# that yields assignment lists a, such that each assignment satisfies:
# - a_i < s_i for all i
# - \exists k: (2k+1) \prod{a_i + 1} == t
# - fixed or (\prod{a_i} == 0)
#
# Setting s = \prod{p_i^s_i}, a = \prod{p_i^a_i}, the effect is that:
#   tau(n) = t & gcd(s, n) = a -> \exist q: n = a q^2.
#
# This implementation is very simplistic, and expects only to be called
# with relatively small numbers: it loops over each possible value for
# a_0, and calls itself recursively to match the rest. For larger numbers
# you would at least want to prune when the tail cannot provide the powers
# of 2 required, by passing round an additional two parameters for required
# and available powers of 2.
#
sub iter_square_kernel_assignment {
	my($t, $s, $fixed) = @_;
	my($head, $tail) = ($s->[0], [ @$s[1 .. $#$s] ]);
	my $curval = -1;
	my $iter;
	return sub {
		while (1) {
			if ($iter) {
				my $result = $iter->();
				return [ $curval, @$result ] if $result;
				$iter = undef;
			}
			++$curval;
			return undef if $curval >= $head;
			my($t2, $fail) = @{ divrem($t, $curval + 1) };
			next if $fail;

			my $now_fixed = $fixed || ($curval == 0);
			if (@$tail) {
				$iter = iter_square_kernel_assignment($t2, $tail, $now_fixed);
			} elsif ($now_fixed && ($t2 & 1)) {
				# all required conditions have been met
				return [ $curval ];
			}
		}
	};
}

#
# n+kd == xp^y (mod p^{y+1}) is suppressible when y+1 ~| tau(n).
#
# More generally:
#	tau(m) ~| tau(n)  and  n+kd == m (mod m rad(m)) => tau(n+kd) != tau(n)
#
# However, given m = \prod p_i^a_i, if a) tau(m) > tau(n), or better:
#	a)  \not \exists k: tau(km) = tau(n)
# or:
#	b)  \exists i: tau(m / p_i^a_i) ~| tau(n)
# we will already have suppressed a superset of what this gives us.
#   
sub test_m_rad_m {
	my($c, $mradm, $fmradm) = @_;
#optionally: try this for (easier) prime powers only
#return if @{ $fmradm->[0] } > 1;
	my($tm, $radm, $fm) = (1, 1, [ $fmradm->[0], [ ] ]);
	for my $i (0 .. $#{ $fm->[0] }) {
		my $a_i = $fmradm->[1][$i];
		# it's not of the form m rad(m) unless every power > 1
		return if $a_i == 1;
		$radm *= $fm->[0][$i];
		$tm *= $a_i;
		$fm->[1][$i] = $a_i - 1;
	}
	my $m = $mradm / $radm;
	my $tn = $c->tau;
	# case a (coarse version)
	return if $tm > $tn;

	# main requirement
	return if ($tn % $tm) == 0;

	for my $i (0 .. $#{ $fm->[0] }) {
		my $tm_i = $tm / ($fm->[1][$i] + 1);
		# case b
		return if ($tn % $tm_i) != 0;
	}

	my $iter_coprime = iter_coprime($radm);
	while (my $cp = $iter_coprime->()) {
$c->debug && warn "given $m rad($m) qualifies, suppress $m * $cp mod $mradm\n";
		series($c, $m * $cp, $mradm, 0);
	}
}

#
# Given integer m, returns an iterator that will return in succession
# each of the \phi(m) integers from 0 .. m-1 that are coprime to m.
#
sub iter_coprime {
	my($m) = @_;
	my $cur = 0;
	return sub {
		while (++$cur < $m) {
			return $cur if gcd($cur, $m) == 1;
		}
		return undef;
	};
}

#
# Return min of values in arrayref.
#

sub min {
	my($a) = @_;
	die "No values to take min of" unless @$a;
	my $min = $a->[0];
	($min > $_) && ($min = $_) for @$a;
	return $min;
}

#
# Return sum of values in arrayref.
#
sub sum {
	my($a) = @_;
	my $n = 0;
	$n += $_ for @$a;
	return $n;
}

#
# Given n>=1, return max(k): 2^k <= n.
#
sub maxpow2arith {
	my $n = shift;
	my $pow = 0;
	while ($n > 1) {
		++$pow;
		$n >>= 1;
	}
	return $pow;
}

#
# Given n, return max(k): 2^k | n.
#
sub maxpow2mult {
	my $n = shift;
	my $pow = 0;
	while (!($n & 1)) {
		++$pow;
		$n >>= 1;
	}
	return $pow;
}

#
# Given factorisation of n = [ p[], pow[] ], return rad(n) = prod(p[i])
#
sub rad_factor {
	my($f) = @_;
	my $rad = PARI(1);
	$rad *= $_ for @{ $f->[0] };
	return $rad;
}

#
# Given factorisation of n = [ p[], pow[] ], return tau(n) = prod(pow[i] + 1)
#
sub tau_factor {
	my($f) = @_;
	my $tau = 1;
	$tau *= $_ + 1 for @{ $f->[1] };
	return $tau;
}

#
# Given n, d return the least divisor of n >= d.
# Assumed d <= n.
#
sub first_divisor {
	my($n, $d) = @_;
	++$d while gcd($d, $n) < $d;
	return $d;
}

#
# Given [ p[], pow[] ] return the n of which it is the factorisation.
#
sub unfactorint {
	my($f) = @_;
	my $n = 1;
	for (0 .. $#{ $f->[0] }) {
		$n *= $f->[0][$_] ** $f->[1][$_];
	}
	return $n;
}

#
# Given n, return an iterator that yields each factorisation of n into
# parts > 1, or undef.
#
sub iter_factor {
	my $n = shift;
	my $f = [ $n ];
	return sub {
		return undef unless @$f;
		my $r = [ @$f ];
		my $spare = 1;
		ITERFAC: while (@$f) {
			my $last = pop @$f;
			my $prod = $spare * $last;
			for my $d ($spare + 1 .. int($prod / 2)) {
				my($q, $rem) = @{ divrem($prod, $d) };
				next if $rem;
				push @$f, $q, $d;
				last ITERFAC;
			}
			$spare = $prod;
		}
		return @$r ? $r : undef;
	};
}

{
	my @seq_seen;
	#
	# rootseq(n, tau, f, g, constraint)
	# - search for arithmetic sequence n+kd, 0<=k<=f, with tau(n+kd)=tau(n)
	# - search with d in the range g=[min, max]
	# - check only those d that satisfy constraints in the Constraint object
	#
	sub rootseq {
		my($c) = @_;
		my $count = $c->tell_count;
		my($n, $f, $tau) = ($c->n, $c->f, $c->tau);
		my $k = $f - 1;
		my $tester = prepare_tester($c);
		my $cur;
		$c->init();
		CUR: while ($cur = $c->next()) {
			report_reach($n, $f, $cur, $c), $count = $c->tell_count unless --$count;
			for (0 .. $#$tester) {
				$tester->[$_]->($cur)
					#|| (report_seq($n, $f, $cur), next CUR)
					#|| next CUR
					|| ($seq_seen[$_]++ || report_seq($n, $f, $cur), next CUR)
					#|| (++$seq_seen[$_-1], next CUR)
			}
			report_reach($n, $f, $cur, $c);
			return $cur;
		}
		report_reach($n, $f, $c->cur, $c);
		return undef;
	}

	sub report_reach {
		my($n, $f, $cur, $c) = @_;
		my $t = $c->elapsed();
		my($tests, $skipped, $kept) = ($c->tests(), $c->skipped(), $c->kept());

		printf <<OUT, $t, $n, $f, $cur, $kept, $skipped, $tests, join ' ', map $_ || 0, @seq_seen;
301 After %.2fs for (%s, %s) reach d=%s (keep %s, skip %s with %s tests) seen [%s]
OUT
	}
}

#
# Returns an arrayref of subrefs, that (in some order) test whether each of
# the candidate targets n+kd has the required number of factors.
# Each subref accepts a single argument (d), and returns a boolean: TRUE
# means tau(n+kd) = tau(n).
#
# We try to arrange the order and strategy of the testing subrefs to optimize
# speed:
# - we can test primality much faster than we can factorize
# - we want to test first those least likely to return TRUE (all other things
#   being equal)
# - generally the most constrained are least likely to return true; that
#   probably means that given g=gcd(n,k) we should test those k that
#   maximize tau(g) first
# - additionally, we'd prefer not to multiply up with known factors, but
#   we must take care to elide only fixed powers (so we have a known tau)
# - if we had a fast issquare() check, that would also be a useful thing
#   to take advantage of
#
# eg for f(125), f(343) we can use prime checks

sub prepare_tester {
	my($c) = @_;
	my($n, $f, $tau, $min) = ($c->n, $c->f, $c->tau, $c->min);
	if ($tau == 2) {
		# all the targets must be prime; it may still be useful to test them
		# in reverse order, but I suspect the faster checking on smaller
		# numbers more than makes up for the reduced chance they are nonprime
		return [ map {
			my $k = $_;
			sub { isprime($n + $_[0] * $k) }
		} 1 .. $f - 1 ];
	}
	my($np, $na) = @{ factorint($n) };
	my(%seen, @tester);
	if (
		$tau == 4
		&& @$np == 2
	) {
		for my $p (@$np) {
			next if $min <= $p ** 3;
			my $q = $n / $p;
			for my $xi (1 .. int(($f - 1) / $p)) {
				my $ki = $p * $xi;
				next if $seen{$ki}++;
				# pq + xpd = p(q+xd)
				push @tester, sub { isprime($q + $xi * $_[0]) };
			}
		}
	}
	for my $k (1 .. $f - 1) {
		next if $seen{$k};
		push @tester, sub { $tau == tau($n + $_[0] * $k) };
	}
	return \@tester;
}

sub report_seq {
	my($n, $f, $d) = @_;
	my $flen = length($f);
	my $vlen = length($n + $f * $d);
	for (0 .. $f) {
		my $v = $n + $d * $_;
		printf <<OUT, $flen, $_, tau($v), $vlen, $v, pf($v);
211 Sequence % *s: % 2s = tau(% *s = %s)
OUT
	}
}

sub check_limit {
	my($n, $f) = splice @_, 0, 2;
	my $max = 0;
	($max < $_) && ($max = $_) for @_;
	return 1 if $f <= $max;
	printf <<OUT, $n, $max, $f;
401 Error: f(%s) <= %s, you asked for %s.
OUT
	return undef;
}

sub phash {
	my $max = shift;
	return PARI(1) if $max <= 1;
	my $mult = PARI(2);
	my $p = 1;
	while (1) {
		$p = nextprime($p);
		last if $p >= $max;
		$mult *= $p;
	}
	return $mult;
}

sub pf {
	my $n = shift;
	my($prime, $power);
	eval {
		($prime, $power) = @{ factorint($n) };
	};
	use Data::Dumper;
	print(Dumper($n), "pf($n) failed: $@"), exit(0) if $@;
	my $s = join '.', map {
		$power->[$_] == 1 ? $prime->[$_] : "$prime->[$_]^$power->[$_]"
	} 0 .. $#$prime;
	($prime, $power) = (undef, undef);
	return $s;
}

#
# Return ordered representation of prime factors and canonical signature for n.
# Signature is a string consisting of the powers of the prime factors in
# descending order, separated by dots. The factors are similarly ordered.
#
sub facsig {
	my $n = shift;
	# my($p, $pp) = @{ factorint($n) };
	#
	# HACK: try to dodge coredumps
	#
	my($p, $pp);
	{
		my($f) = factorint($n);
		$p = [ map PARI("$_"), @{ $f->[0] } ];
		$pp = [ map PARI("$_"), @{ $f->[1] } ];
		$f = undef;
	}
	my @order = sort {
		$pp->[$b] <=> $pp->[$a]
	} 0 .. $#$pp;
	my $fac = [ [ @$p[@order] ], [ @$pp[@order] ] ];
	my $sig = join '.', @{ $fac->[1] };
	return ($fac, $sig);
}

sub nextprime {
	my $p = shift;
	DIV: while (1) {
		$p += 2;
		my $d = 3;
		while (1) {
			last if $d * $d > $p;
			next DIV unless $p % $d;
			$d += 2;
		}
		return $p;
	}
}

sub tau {
	my $n = shift;
	my $k = 1;
	my $power;
	eval {
		(undef, $power) = @{ factorint($n) };
		$k *= $_ + 1 for @$power;
	};
	use Carp; Carp::confess("tau($n) failed: $@") if $@;
	return $k;
}
