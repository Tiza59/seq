#!/opt/maths/bin/perl
use strict;
use warnings;
no warnings qw{ recursion };

=head1 A051602

Given n points placed on a plane, what is the greatest number of squares
they can describe?

Sean Irvine's Java code assumes a) that the points can be restricted to
integer grid points; b) that n points will span at most ceil(sqrt(n))
along either axis. It then attempts to enumerate all sets of points
within those restrictions.

Let's try a different approach: start with a unit square, and assume
that every maximal arrangement can be built recursively by extending
a smaller arrangement one or two points at a time, adding (at least)
one new square each time.

I think it is provable that this will also generate points only at
integer coordinates; it will be interesting to see a) whether it
yields the same maxima as Sean's program, and b) what the least and
greatest spans of maximal arrangements it will find.

=cut

my $n = shift(@ARGV) or die "Usage: $0 <n>\n";
if ($n < 4) { print "0\n"; exit };
if ($n == 4) { print "1\n"; exit };

my @point = ([0, 0], [0, 1], [1, 0], [1, 1]);
my %grid = map +(_loc($point[$_]) => $_), 0 .. $#point;

my %start = (
    points => 4,
    squares => 1,
    try3 => [ 4, 1, 0 ],
    try2 => [ 3, 2, 0 ],
    best => 1,
    span => [ 0, 1, 0, 1 ],
);
my $minspan = [ 1, 1 ];
my $maxspan = [ 1, 1 ];
my $visit = 0;
try_next($n, \%start);
printf "%s %s %sx%s %sx%s (%s)\n",
    $n, $start{best}, (map $_ + 1, @$minspan, @$maxspan), $visit;
exit;

sub _loc {
    my $p = $_[0];
    "$p->[0]:$p->[1]";
}

sub copy {
    my %this = %{ $_[0] };
    $this{try3} = [ @{ $this{try3} } ];
    $this{try2} = [ @{ $this{try2} } ];
    $this{span} = [ @{ $this{span} } ];
    return \%this;
}

sub _report {
    my($points, $score) = @_;
    print "$score: ", join(' ', map _loc($_), @point), "\n";
    return;
}

sub try_with {
    my($max, $parent, $new) = @_;
    my $squares = $parent->{squares};
    my $span = [ @{ $parent->{span} } ];
    my %gridp;
    my $i = $parent->{points};
    for my $p (@$new) {
        my $loc = _loc($p);
die("clash on $loc") if defined($grid{$loc}) || defined($gridp{$loc});
        $point[$i] = $p;
        $gridp{$loc} = $i;
        local @grid{keys %gridp} = values %gridp;
        $squares += find_squares($i);
        my($px, $py) = @$p;
        $span->[0] = $px if $span->[0] > $px;
        $span->[1] = $px if $span->[1] < $px;
        $span->[2] = $py if $span->[2] > $py;
        $span->[3] = $py if $span->[3] < $py;
        ++$i;
    }
    local @grid{keys %gridp} = values %gridp;
    local $parent->{span} = $span;
    local $parent->{points} = $i;
    local $parent->{squares} = $squares;

    if ($squares >= $parent->{best}) {
        my($spanx, $spany) = ($span->[1] - $span->[0], $span->[3] - $span->[2]);
        ($spanx, $spany) = ($spany, $spanx) if $spanx < $spany;
        if ($squares > $parent->{best}) {
            $minspan = [ $spanx, $spany ];
            $maxspan = [ $spanx, $spany ];
            print "${spanx}x$spany ";
            _report($i, $squares);
        } else {
            my $new = 0;
            ++$new, $minspan->[0] = $spanx if $minspan->[0] > $spanx;
            ++$new, $minspan->[1] = $spany if $minspan->[1] > $spany;
            ++$new, $maxspan->[0] = $spanx if $maxspan->[0] < $spanx;
            ++$new, $maxspan->[1] = $spany if $maxspan->[1] < $spany;
            print("${spanx}x$spany "), _report($i, $squares) if $new;
        }
        $parent->{best} = $squares;
    }

    try_next($max, $parent);
    return;
}

sub try_next {
    ++$visit;
    my($max, $parent) = @_;
    my $child = copy($parent);
    my $points = $child->{points};
    my %seen;

    if ($points + 2 <= $max) {
        # try to extend 2 points into a square, two ways
        my $try2 = $child->{try2};
        while ($try2->[0] < $points) {
            my $pair = try2(@point[@$try2[0, 1]], $try2->[2]);
#use Data::Dumper; warn Dumper({ t2 => $try2, r => $pair });
            if ($pair) {
                try_with($max, $child, $pair);
                $seen{_loc($_)} = 1 for @$pair;
            }
            $try2->[2] = 1, next if $try2->[2] == 0;
            $try2->[2] = 0;
            ++$try2->[1];
            next if $try2->[1] < $try2->[0];
            $try2->[1] = 0;
            ++$try2->[0];
        }
    }

    if ($points + 1 <= $max) {
        # try to extend 3 points into a square
        my $try3 = $child->{try3};
        while ($try3->[0] < $points) {
            my $fourth = try3(@point[@$try3]);
#use Data::Dumper; warn Dumper({ t3 => $try3, r => $fourth });
            if ($fourth && !$seen{_loc($fourth)}++) {
                try_with($max, $child, [ $fourth ]);
            }
            ++$try3->[2];
            next if $try3->[2] < $try3->[1];
            $try3->[2] = 0;
            ++$try3->[1];
            next if $try3->[1] < $try3->[0];
            $try3->[1] = 1;
            ++$try3->[0];
        }
    }

    $parent->{best} = $child->{best} if $parent->{best} < $child->{best};
    return;
}

sub try2 {
    my($pi, $pj, $dir) = @_;
    my($pix, $piy) = @$pi;
    my($pjx, $pjy) = @$pj;
    my($dx, $dy) = ($pjx - $pix, $pjy - $piy);
    my $pk = $dir ? [ $pix - $dy, $piy + $dx ] : [ $pix + $dy, $piy - $dx ];
    my $pl = $dir ? [ $pjx - $dy, $pjy + $dx ] : [ $pjx + $dy, $pjy - $dx ];
    return if grep defined, @grid{ _loc($pk), _loc($pl) };
    return [ $pk, $pl ];
}

sub try3 {
    my($pi, $pj, $pk) = @_;
    my($pix, $piy) = @$pi;
    my($pjx, $pjy) = @$pj;
    my($pkx, $pky) = @$pk;
#warn "[ $pix:$piy $pjx:$pjy $pkx:$pky ]\n";
    my $pl;
    my($djx, $djy) = ($pjx - $pix, $pjy - $piy);
    if ($pkx == $pix + $djy && $pky == $pix - $djx) {
        $pl = [ $pjx + $djy, $pjy - $djx ];
    } elsif ($pkx == $pjx + $djy && $pky == $pjy - $djx) {
        $pl = [ $pix + $djy, $piy - $djx ];
    } elsif ($pkx == $pix - $djy && $pky == $pix + $djx) {
        $pl = [ $pjx - $djy, $pjy + $djx ];
    } elsif ($pkx == $pjx - $djy && $pky == $pjy + $djx) {
        $pl = [ $pix - $djy, $piy + $djx ];
    } else {
        my($dkx, $dky) = ($pkx - $pix, $pky - $piy);
        if ($pjx == $pkx + $dky && $pjy == $pky - $dkx) {
            $pl = [ $pix + $dky, $piy - $dkx ];
        } elsif ($pjx == $pkx - $dky && $pjy == $pky + $dkx) {
            $pl = [ $pix - $dky, $piy + $dkx ];
        }
    }
#warn "[ $pix:$piy $pjx:$pjy $pkx:$pky ] => [ @$pl ]\n" if $pl;
    if ($pl && !defined($grid{_loc($pl)})) {
        return $pl;
    }
    return;
}

sub find_squares {
    my($i) = @_;
    my $count = 0;
    my($pix, $piy) = @{ $point[$i] };
    for my $j (0 .. $i - 1) {
        my($pjx, $pjy) = @{ $point[$j] };
        my($dx, $dy) = ($pjx - $pix, $pjy - $piy);

        my $k = $grid{_loc([ $pix + $dy, $piy - $dx ])};
        ++$count if defined($k) && $k > $j
                && defined $grid{_loc([ $pjx + $dy, $pjy - $dx ])};

        $k = $grid{_loc([ $pix - $dy, $piy + $dx ])};
        ++$count if defined($k) && $k > $j
                && defined $grid{_loc([ $pjx - $dy, $pjy + $dx ])};
    }
#warn "find $count for [ @{ $point[$i] } ]\n";
    return $count;
}
