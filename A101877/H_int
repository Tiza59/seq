#!/opt/maths/bin/perl -w
use strict;
use Math::BigRat;
use Math::BigInt;
my $rat0 = Math::BigRat->new(0);
my $rat1 = Math::BigRat->new(1);
my $ratm1 = Math::BigRat->new(-1);
my $int1 = Math::BigInt->new(1);

=head1

a(n): The least integer such that there is a sum of distinct unit fractions
equal to _n_, the greatest denominator being a(n).

If a(n) = k then there exist S = [ s_1, s_2, ... s_m ] such that s_m = k,
sum_1^m{1/s_i} = n, and 1 <= i < j <= m => s_i < s_j.

eg f(1) = 1: [ 1 ]
   f(2) = 6: [ 1, 2, 3, 6 ]
   f(3) = 24: [ 1, 2, 3, 4, 5, 6, 8, 9, 10, 15, 18, 20, 24 ]

Proof of f(3): for k = 24, we have a candidate set of 1 .. 24, of which the
prime powers greater than 12 can immediately be discarded as unusable;
the multiples of 11 are unavailable since no partial sum of [ 2/1, 2/2 ]
is divisible by 11; the multiples of 7 are unavailable since no partial
sum of [ 6/1, 6/2, 6/3 ] is divisible by 7.

That leaves the candidate set as S U { 12 }, with a sum of 3 1/12. It
immediately follows that S is a candidate set with the right sum; further,
since the greatest denominator is 24, no two fractions from this candidate
set can be <= 1/12, so no candidate set with a lower maximal element can
sum to 3.

Established values:
  f(1) = 1; f(2) = 6; f(3) = 24; f(4) = 65; f(5) = 184; f(6) = 469
  1200 < f(7) <= 1251
  current: 1220 (probably fail); 1240 (dubious)

Next step: find() redoes an awful lot of work finding each successive
match. Given the require modulus $mod and the number of elements to
discard $count, we could save the array of indices @nfm leading to the
*next found match*, and $lfm, the sum of the *least found match* greater
than the last one actually found.

Then, to find the next match:
- find $min = min(grep defined, {$mod}{$count}->{lfm})
- for each lfm not defined:
  - use the existing multiloop algorithm to find the next lfm
  - aborting if we cannot beat $min
  - but seed it with @nfm as the starting indices
  - and return @nfm as the starting indices of the first found match
    (if different)
  - and replace $min if $lfm is lower
- then delete the selected {$mod}{$count}->{lfm} and return it
- not forgetting to watch out for duplicate sums

=cut

$| = 1;
my $N = shift || 4;
my $skip = shift || 1;
my $S = $rat0;
my @P = (2, 3);
my($limit, %F, %known, @known);

$limit = $_, PP->account($_) for 1 .. $skip - 1;
for ($limit = $skip; 1; ++$limit) {
	my $pp = PP->account($limit) or next;

printf "$limit: S = %.6f (%s)\n", $S, $S;
	next if $S < $N;
	$pp->consider() and exit 0;
}
exit 0;

{
	package PP;
	sub new {
		my($class, $pp) = @_;
		$known{$pp} ||= do {
			my $f = $F{$pp} || $pp;
			my $span = ::vec0($f);
			vec($span, 0, 1) = 1;
			my $self = bless {
				pp => $pp,
				f => $f,
				val => [],
				rec => [],
				span => [ $span ],
				kindex => scalar @known,
				sum => $rat0,
				modsum => 0,
				match => {
					0 => [ [ 0, '' ] ],
				},
				complete => {
					0 => 1,
				},
			}, $class;
			push @known, $self;
			$self;
		};
	}
	sub account {
		my($class, $n) = @_;
		$S += my $rn = ::rec($n);
		my $pp = ::gpp($n);

		my $self = $class->new($pp);
		my $f = $self->{f};
		my $inv = $self->inverse($n / $pp);
		my $pspan = $self->{span}[ $#{ $self->{span} } ];

		push @{ $self->{val} }, $n;
		push @{ $self->{rec} }, $inv;
		push @{ $self->{span} }, ::merge($pspan, $f, $inv);
		$self->{sum} += $rn;
		$self->{modsum} = ($self->{modsum} + $inv) % $f;

		my $cansolve = $self->{cansolve} = vec($pspan, (-$inv) % $f, 1);
		$self->{complete} = {
			0 => !$cansolve && $self->{complete}{0},
		};
		$self->{match} = $cansolve ? {} : { 0 => $self->{match}{0} };

		# if any PP > $pp has solutions, we may need to solve for sum != 0
		return $self if $cansolve;
		for my $i ($self->{kindex} + 1 .. $#known) {
			return $self if $known[$i]->{cansolve};
		}
		return 0;
	}

	sub maybe_solution {
		my($class, $tried, $offset, $fly) = @_;
		my $ointment = $class->span($tried, $offset);
		return 0 unless delete $ointment->{$fly};
		return $class->sol($ointment);
	}
	sub solution {
		my($class, $tried, $offset) = @_;
		return $class->sol($class->span($tried, $offset));
	}
	sub sol {
		my($class, $sol) = @_;
		printf "a(%s) = %s : { %s }\n",
				$N, $limit, join ' ', sort { $a <=> $b } keys %$sol;
		return 1;
	}
	sub span {
		my($class, $tried, $offset) = @_;
		my %sol = map +($_ => 1), 1 .. $limit;
		for my $i ($offset .. $#known) {
			my $pp = $known[$i];
			my $span = $tried->[$i][1];
			if ($span eq '') {
				delete @sol{ @{ $pp->{val} } };
			} else {
				delete @sol{ @{ $pp->{val} }[
					grep !vec($span, $_, 1), 0 .. $#{ $pp->{val} }
				] };
			}
		}
		\%sol;
	}

	sub find {
		my($self, $mod, $max) = @_;
		my $sum = $self->{sum};
		my $min = $sum - $max;
#warn "find: $self->{pp} mod=$mod, min=$min\n";
#$self->Dump;
		for (@{ $self->{match}{$mod} }) {
			return $_ if $_->[0] < $max;
		}
		return undef if $self->{complete}{$mod};
		my $f = $self->{f};
		my $dismod = ($self->{modsum} - $mod) % $f;
		my $number = @{ $self->{val} };
		my $full = ::vec1($number);
		my $rtry; $rtry = sub {
			my($count, $best, $dismod, $min, $index) = @_;
			if ($count == 0) {
				return +($dismod == 0 && $min < $rat0 && $best > $rat0)
						? [ $rat0 => $full ] : undef;
			}
			my $newbest;
			for (my $i = $index - 1; $i >= 0; --$i) {
				my $r = ::rec($self->{val}[$i]);
				last if $r >= $best;
				my $v = $full;
				vec($v, $i, 1) = 0;
				my $mod2 = ($dismod - $self->{rec}[$i]) % $f;
				next unless vec($self->{span}[$i], $mod2, 1);
				my $nextbest = $rtry->(
					$count - 1, $best - $r, $mod2, $min - $r, $i
				) or next;
				$newbest = [ $nextbest->[0] + $r, $nextbest->[1] & $v ];
				$best = $newbest->[0];
			}
			$newbest;
		};

		my $best = [ $sum + $rat1, undef ];
		my $rmin = ::rec($self->{val}[ $#{ $self->{val} } ]);
		for (my $count = 0; $count <= $number; ++$count) {
			last if $count * $rmin > $best->[0];
			my $nextbest = $rtry->($count, $best->[0], $dismod, $min, $number)
					or next;
			$best = $nextbest;
		}
		if (defined $best->[1]) {
			my $result = [ $sum - $best->[0], $best->[1] ];
			push @{ $self->{match}{$mod} }, $result;
			return $result;
		}
		$self->{complete}{$mod} = 1;
		undef;
	}

	sub Dump {
		my $self = { %{+shift} };
		my $count = @{ $self->{val} };
		sub unvec { unpack "b$_[1]", $_[0] }
		sub unrat { "$_[0]" }
		$self->{span} = [ map unvec($_, $self->{f}), @{ $self->{span} } ];
		$self->{sum} = unrat($self->{sum});
		$self->{match} = {
			map +($_ => [
				map [ unrat($_->[0]), unvec($_->[1], $count) ],
						@{ $self->{match}{$_} }
			]), keys %{ $self->{match} }
		};
		use Data::Dumper;
		warn Dumper($self);
	}

	sub consider {
		my $self = shift;
		my $reqpp = $self->{pp};
		my $reqind = $#{ $self->{val} };
		my $rlimit = ::rec($limit);
		my(@tried, @sum, @kept);
		my $botseen = $limit;
		my $try = $#known;
		$tried[$try] = undef;
		$sum[$try + 1] = $S - $N;
		$kept[$try + 1] = $rat0;
		while ($try < @known) {
			my $spare = $sum[$try + 1];
			my $kept = $kept[$try + 1];
			my $pp = $known[$try];
			my $max = ($tried[$try] || [ $pp->{sum} + $rat1 ])->[0];
			my $mod = (
				$pp->{pp} * $pp->{f} <= $limit
				&& !($kept->denominator % $pp->{pp})
			) ? do {
				my $m = $kept->numerator % $pp->{f};
				my $d = ($kept->denominator / $pp->{pp}) % $pp->{f};
				(-$m * $pp->inverse($d)) % $pp->{f};
			} : 0;
#warn "mod $mod - pp * f @{[ $pp->{pp} * $pp->{f} ]}; denom @{[ $kept->denominator % $pp->{pp} ]}\n";
warn "  $pp->{pp}: trying mod $mod max $max ($spare spare; kept $kept)\n";
			my($keeping, $vec) = @{
				$tried[$try] = $pp->find($mod, $max) or do {
					++$try;
					next;
				}
			};
			my $discard = $pp->{sum} - $keeping;
#			next if $pp->{pp} == $reqpp && !vec($vec, $reqind, 1);
			$kept[$try] = $kept + $keeping;
			$sum[$try] = $spare -= $discard;
warn "  $pp->{pp}: found [ @{[ join ' ', map $pp->{val}[$_], grep vec($vec, $_, 1), 0 .. $#{ $pp->{val} } ]} ] leaving $spare (keeping $keeping, discard $discard)\n";
			++$try, next if $spare < $rat0;
			next if $spare > $rat0 && $spare < $rlimit;
			return $self->solution(\@tried, $try) if $spare == $rat0;
			if ($spare->numerator == $int1 && $spare->denominator <= $limit) {
warn("  maybe solution: $spare\n"),
				$self->maybe_solution(\@tried, $try, $spare->denominator)
						&& return 1;
			}
			$tried[--$try] = undef if $try;
			$botseen = $known[$try]{pp} if $botseen >= $pp->{pp};
		}
		warn "... reached $botseen\n";
		return 0;
	}

	sub inverse {
		my($self, $b) = @_;
		my $a = $self->{f};
		return 1 if $a == 1;
		my($p, $q, $r, $s) = (1, 0, 0, 1);
		while ($b) {
			($a, $b, my $d) = ($b, $a % $b, int($a / $b));
			($p, $q, $r, $s) = ($r, $s, $p - $d * $r, $q - $d * $s);
		}
		$q % $self->{f};
	}
}

sub vec0 {
	my $bits = shift;
	my $s = "";
	vec($s, $bits - 1, 1) = 0;
	$s;
}
sub vec1 {
	my $bits = shift;
	my $s = "\xff" x int(1 + ($bits / 8));
	$s =~ s/\xff\Z/chr((1 << ($bits % 8)) - 1)/e;
	$s;
}

{
	my @p; BEGIN { @p = (2, 3) }
	sub nextprime {
		my $p = $p[$#p];
		DIV: while (1) {
			$p += 2;
			my $pc = 0;
			while (1) {
				my $d = $p[$pc++];
				last if $d * $d > $p;
				next DIV unless $p % $d;
			}
			$p[@p] = $p;
			return $p;
		}
	}

	sub factors {
		my $n = shift;
		my($pc, @result) = (0);
		while ($n > 1) {
			my $d = $p[$pc++] || nextprime();
			if ($d * $d > $n) {
				push @result, $n;
				$n = 1;
			} else {
				my $pp = 1;
				$pp *= $d, $n /= $d while 0 == ($n % $d);
				$F{$pp} = $d if $pp > $d;
				push @result, $pp if $pp > 1;
			}
		}
		\@result;
	}
	# return greatest prime power of n
	sub gpp {
		my $s = 1;
		$s = $s < $_ ? $_ : $s for @{ factors(shift) };
		$s;
	}
}

sub gcd {
	my($a, $b) = @_;
	return gcd($b, $a) if $a > $b;
	return $b unless $a;
	return gcd($b % $a, $a);
}

{
	my %reccache;
	sub rec {
		my $n = shift;
		$reccache{$n} ||= Math::BigRat->new("1/$n");
	}
}

use Inline C => <<INLINE; no AutoLoader;
SV* merge(unsigned char* vin, unsigned int fac, unsigned int mod) {
	unsigned int size = (fac + 7) / 8;
	unsigned int off, value, byte, inbyte;
	unsigned int tail = vin[0] + ((size > 1) ? (vin[1] << 8) : 0);
	unsigned char *vout;
	SV* sv = newSVpvn("", 0);
	vout = SvGROW(sv, size + 1);
	SvCUR(sv) = size;
	for (byte = 0; byte < size; ++byte) {
		off = (byte * 8 + fac - mod) % fac;
		inbyte = off / 8;
		value = vin[inbyte] + (
			(inbyte + 1 == size) ? 0 : (vin[inbyte + 1] << 8) 
		) + (
			(inbyte + 2 >= size) ? (
				tail << ((fac & 7) + ((inbyte + 1 == size) ? 0 : 8))
			) : 0
		);
		vout[byte] = vin[byte] | (unsigned char)((value >> (off % 8)) & 255);
	}
	vout[size - 1] &= (1 << (fac & 7)) - 1;
	return sv;
}
INLINE
