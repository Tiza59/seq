#!/opt/maths/bin/perl -w
use strict;
use Math::BigRat;
my $rat0 = Math::BigRat->new(0);

=head1

a(n): The least integer such that there is a sum of distinct unit fractions
equal to _n_, the greatest denominator being a(n).

If a(n) = k then there exist S = [ s_1, s_2, ... s_m ] such that s_m = k,
sum_1^m{1/s_i} = n, and 1 <= i < j <= m => s_i < s_j.

eg f(1) = 1: [ 1 ]
   f(2) = 6: [ 1, 2, 3, 6 ]
   f(3) = 24: [ 1, 2, 3, 4, 5, 6, 8, 9, 10, 15, 18, 20, 24 ]

Proof of f(3): for k = 24, we have a candidate set of 1 .. 24, of which the
prime powers greater than 12 can immediately be discarded as unusable;
the multiples of 11 are unavailable since no partial sum of [ 2/1, 2/2 ]
is divisible by 11; the multiples of 7 are unavailable since no partial
sum of [ 6/1, 6/2, 6/3 ] is divisible by 7.

That leaves the candidate set as S U { 12 }, with a sum of 3 1/12. It
immediately follows that S is a candidate set with the right sum; further,
since the greatest denominator is 24, no two fractions from this candidate
set can be <= 1/12, so no candidate set with a lower maximal element can
sum to 3.

=cut

$| = 1;
my $N = shift || 4;
my $S = $rat0;
my @P = (2, 3);
my($limit, %F, %known, @known);

for ($limit = 1; 1; ++$limit) {
	my $pp = PP->account($limit) or next;

printf "$limit: S = %.6f (%s)\n", $S, $S;
	next if $S < $N;

	$pp->consider() and exit 0;
}
exit 0;

{
	package PP;
	sub new {
		my($class, $pp) = @_;
		$known{$pp} ||= do {
			my $f = $F{$pp} || $pp;
			my $span = "\x0" x int(($f + 8) / 8);
			vec($span, 0, 1) = 1;
			my $full = "\xff" x int(($f + 8) / 8);
			$full =~ s/\xff\Z/chr((1 << ($f % 8)) - 1)/e;
			my $self = bless {
				pp => $pp,
				f => $f,
				val => [],
				rec => [],
				harm => [],
				span => [ $span ],
				full => $full,
				kindex => scalar @known,
				sum => $rat0,
				match => {
					0 => [ [ 0, '' ] ],
				},
				complete => {
					0 => 1,
				},
			}, $class;
			push @known, $self;
			$self;
		};
	}
	sub account {
		my($class, $n) = @_;
		$S += my $rn = ::rec($n);
		my $pp = ::gpp($n);

		my $self = $class->new($pp);
		my $f = $self->{f};
		my $inv = $self->inverse($n / $pp);
		my $pspan = $self->{span}[ $#{ $self->{span} } ];

		push @{ $self->{val} }, $n;
		push @{ $self->{rec} }, $inv;
		push @{ $self->{span} }, ::merge($pspan, $f, $inv);
		push @{ $self->{harm} }, $rn;
		$self->{sum} += $rn;

		my $cansolve = $self->{cansolve} = vec($pspan, (-$inv) % $f, 1);
		$self->{complete} = {
			0 => !$cansolve && $self->{complete}{0},
		};

		# if any PP > $pp has solutions, we may need to solve for sum != 0
		return $self if $cansolve;
		for my $i ($self->{kindex} + 1 .. $#known) {
			return $self if $known[$i]->{cansolve};
		}
		return 0;
	}

	sub maybe_solution {
		my($class, $index, $offset, $fly) = @_;
		my $ointment = $class->span($index, $offset);
		return 0 unless delete $ointment->{$fly};
		return $class->sol($ointment);
	}
	sub solution {
		my($class, $index, $offset) = @_;
		return $class->sol($class->span($index, $offset));
	}
	sub sol {
		my($class, $sol) = @_;
		printf "a(%s) = %s : { %s }\n",
				$N, $limit, join ' ', sort { $a <=> $b } keys %$sol;
		return 1;
	}
	sub span {
		my($class, $index, $offset) = @_;
		my %sol = map +($_ => 1), 1 .. $limit;
		for my $i ($offset .. $#known) {
			my $pp = $known[$i];
			my $span = $pp->{match}{0}[$index->[$i]][1];
			if ($span eq '') {
				delete @sol{ @{ $pp->{val} } };
			} else {
				delete @sol{ @{ $pp->{val} }[ grep !vec($span, $_, 1), 0 .. $#{ $pp->{val} } ] };
			}
		}
		\%sol;
	}

	sub find {
		my($self, $index, $mod) = @_;
		return $self->{match}{$mod}[$index] if $self->{complete}{$mod};
#		die "find not yet implemeneted ...\n";

		# simplistic approach: complete it first
		my $s = -1;
		$self->{match}{$mod} = [
			grep { my $t = ($_->[0] != $s); $s = $_->[0]; $t }
			sort { $b->[0] <=> $a->[0] }
			$self->findall($mod, $#{ $self->{val} })
		];
		$self->{complete}{$mod} = 1;
#$self->Dump;
		$self->{match}{$mod}[$index];
	}

	sub Dump {
		my $self = { %{+shift} };
		my $count = @{ $self->{val} };
		sub unvec { unpack "b$_[1]", $_[0] }
		sub unrat { "$_[0]" }
		$self->{span} = [ map unvec($_, $self->{f}), @{ $self->{span} } ];
		$self->{full} = unvec($self->{full}, $self->{f});
		$self->{sum} = unrat($self->{sum});
		$self->{harm} = [ map unrat($_), @{ $self->{harm} } ];
		$self->{match} = {
			map +($_ => [
				map [ unrat($_->[0]), unvec($_->[1], $count) ], @{ $self->{match}{$_} }
			]), keys %{ $self->{match} }
		};
		use Data::Dumper;
		warn Dumper($self);
	}

	sub findall {
		my($self, $mod, $max) = @_;
		return $mod ? () : [ 0 => '' ] if $max < 0;
		return () unless vec $self->{span}[$max + 1], $mod, 1;
		my $incl = ($mod - $self->{rec}[$max]) % $self->{f};
		($self->findall($mod, $max - 1), map {
			$_->[0] += $self->{harm}[$max];
			vec($_->[1], $max, 1) = 1;
			$_
		} $self->findall($incl, $max - 1));
	}

	sub consider {
		my $self = shift;
		my $reqpp = $self->{pp};
		my $reqind = $#{ $self->{val} };
		my(@index, @sum, @kept);
		my $topkept = 0;
		my $botseen = $limit;
		my $try = $#known;
		$index[$try] = -1;
		$sum[$try + 1] = $S - $N;
		$kept[$try + 1] = $rat0;
		while ($try < @known) {
			my $spare = $sum[$try + 1];
			my $kept = $kept[$try + 1];
			my $pp = $known[$try];
			++$index[$try];
			my $mod = (
# FIXME: topkept should be the top _number_ kept, not the top power
				$pp->{pp} * $pp->{f} <= $topkept
				&& !($kept->denominator % $pp->{pp})
			) ? $pp->inverse($kept->numerator % $pp->{f}) : 0;
#warn "mod $mod - pp * f @{[ $pp->{pp} * $pp->{f} ]}; topkept $topkept; denom @{[ $kept->denominator % $pp->{pp} ]}\n";
#warn "$pp->{pp}: trying $index[$try] mod $mod ($spare spare)\n";
			my $match = $pp->find($index[$try], $mod) or do {
				++$try;
				next;
			};
			next if $pp->{pp} == $reqpp && !vec($match->[1], $reqind, 1);
# FIXME: topkept should be the top _number_ kept, not the top power
			$topkept = $pp->{pp}
					if $match->[0] > 0 && ($topkept < $pp->{pp});
			$kept[$try] = $kept + $match->[0];
			$sum[$try] = $spare -= $pp->{sum} - $match->[0];
#warn "$pp->{pp}: found [ @{[ join ' ', map $pp->{val}[$_], grep vec($match->[1], $_, 1), 0 .. $#{ $pp->{val} } ]} ] leaving $spare\n";
			if ($spare < 0) {
				++$try;
				next;
			}
			return $self->solution(\@index, $try) if $spare == 0;
#warn("maybe solution: $spare\n"),
			$self->maybe_solution(\@index, $try, $spare->denominator) && return 1
					if $spare->numerator == 1;
			$index[--$try] = -1 if $try;
			$botseen = $known[$try]{pp} if $botseen >= $pp->{pp};
		}
		warn "... reached $botseen\n";
		return 0;
	}

	sub inverse {
		my($self, $b) = @_;
		my $a = $self->{f};
		return 1 if $a == 1;
		my($p, $q, $r, $s) = (1, 0, 0, 1);
		while ($b) {
			($a, $b, my $d) = ($b, $a % $b, int($a / $b));
			($p, $q, $r, $s) = ($r, $s, $p - $d * $r, $q - $d * $s);
		}
		$q % $self->{f};
	}
}

{
	my @p; BEGIN { @p = (2, 3) }
	sub nextprime {
		my $p = $p[$#p];
		DIV: while (1) {
			$p += 2;
			my $pc = 0;
			while (1) {
				my $d = $p[$pc++];
				last if $d * $d > $p;
				next DIV unless $p % $d;
			}
			$p[@p] = $p;
			return $p;
		}
	}

	sub factors {
		my $n = shift;
		my($pc, @result) = (0);
		while ($n > 1) {
			my $d = $p[$pc++] || nextprime();
			if ($d * $d > $n) {
				push @result, $n;
				$n = 1;
			} else {
				my $pp = 1;
				$pp *= $d, $n /= $d while 0 == ($n % $d);
				$F{$pp} = $d if $pp > $d;
				push @result, $pp if $pp > 1;
			}
		}
		\@result;
	}
	# return greatest prime power of n
	sub gpp {
		my $s = 1;
		$s = $s < $_ ? $_ : $s for @{ factors(shift) };
		$s;
	}
}

sub gcd {
	my($a, $b) = @_;
	return gcd($b, $a) if $a > $b;
	return $b unless $a;
	return gcd($b % $a, $a);
}

#use List::Util qw/ max reduce /;
#sub sum { our($a, $b); reduce { $a + $b } 0, @_ }

{
	my %reccache;
	sub rec {
		my $n = shift;
		$reccache{$n} ||= Math::BigRat->new("1/$n");
	}
}

use Inline C => <<INLINE; no AutoLoader;
SV* merge(unsigned char* vin, unsigned int fac, unsigned int mod) {
	unsigned int size = (fac + 7) / 8;
	unsigned int off, value, byte, inbyte;
	unsigned int tail = vin[0] + ((size > 1) ? (vin[1] << 8) : 0);
	unsigned char *vout;
	SV* sv = newSVpvn("", 0);
	vout = SvGROW(sv, size + 1);
	SvCUR(sv) = size;
	for (byte = 0; byte < size; ++byte) {
		off = (byte * 8 + fac - mod) % fac;
		inbyte = off / 8;
		value = vin[inbyte] + (
			(inbyte + 1 == size) ? 0 : (vin[inbyte + 1] << 8) 
		) + (
			(inbyte + 2 >= size) ? (
				tail << ((fac & 7) + ((inbyte + 1 == size) ? 0 : 8))
			) : 0
		);
		vout[byte] = vin[byte] | (unsigned char)((value >> (off % 8)) & 255);
	}
	vout[size - 1] &= (1 << (fac & 7)) - 1;
	return sv;
}
INLINE
