#!/opt/maths/bin/perl -w
use strict;
$| = 1;

=head1 A048669 - the Jacobsthal function

For a given n, this function yields one more than the longest possible
run of consecutive integers each sharing a factor with n.

We'll actually calculate the length of run, A048669(n)-1, and call it Jd(n).

Note that:
- we only need to know the distinct prime factors p_i of n
- if sum{ceil(k/p_i)} < k, then Jd(n) < k
- for n odd, Jd(2n) = 2Jd(n)+1

=cut

die "Usage: $0 <p1> <p2> ...\n" unless @ARGV;
my $sorted = sortedUniquedNumbers(\@ARGV);

my $t0 = (times)[0];
my $result = Jd($sorted);
my $t1 = (times)[0];

printf "[%.2f] Jd = %s\n", $t1 - $t0, $result;
exit 0;

=head2 Jd ( primes )

Given an arrayref of distinct I<primes> sorted in ascending order,
finds and returns the length of the longest possible run of consecutive
integers such that each element of the run is divisible by at least one
of the supplied primes.

The prime C<2> is special-cased, the remainder involve searching
recursively for possible assignment of the starting point of the run
mod I<p>, a prime in the list.

If there are I<k> primes (excluding C<2>), each successive length is
tried until at some length we fail to find a possible run.

=cut

sub Jd {
	my($sorted) = @_;
	return 0 if @$sorted == 0;
	return 1 if @$sorted == 1;
	my $had_2 = 0;
	if ($sorted->[0] == 2) {
		$had_2 = 1;
		shift @$sorted;
	}

	my @pp = map +{
		p => $sorted->[$_],
		remain => @$sorted - $_,
	}, 0 .. $#$sorted;

	my $best = JdFindBest(\@pp);
	return $had_2 ? 2 * $best + 1 : $best;
}

=head2 structure

{
	# fixed for the lifetime
	p => this prime,
	remain => count of primes from here to end of list

	# reset when k changes
	max => maximum copies of this prime possible for this k
	stolen => number of guaranteed collisions with first prime

	# reset on every iteration, maybe tweaked when k changes
	v => k-bit vector, bits set at each offset already hit by assigned primes
	needed => number of bits clear in v
	excess => maximum degrees of freedom

	# reset on every iteration, no tweaks
	offset => current assigned offset in run for first multiple of this prime
	symmetric => TRUE if offsets for all preceding primes are placed
		symmetrically within the run
}

=cut

sub JdFindBest {
	my($pp) = @_;
	my $k = @$pp + 1;	# we have a simple solution with no primes fixed
	my $index;

	$pp->[0]{offset} = -1;
	$index = JdSetPP($pp, $k, 0);
	while ($index >= 0) {
		my $pi = $pp->[$index];
		my $needed = $pi->{needed};

		# record solution for this $k if we have at least
		# as many unused primes as unfilled slots
		if ($pi->{remain} >= $needed) {
			($k, $index) = JdRecordSolution($pp, $k, $index);
			# retry at the next length
			next;
		}

		# if this (and hence all remaining primes) can only appear once,
		# we have no further chance to find a solution here
		my $underflow = $pi->{max};
		--$index, next if $underflow == 1;

		# for this prime, we want to try starting points from 0 to p-1
		my $p = $pi->{p};
		--$index, next if ++$pi->{offset} >= $p;

		my $pj = $pp->[$index + 1];
		if ($pi->{symmetric}) {
			my $reverse_offset = ($k - 1 - $pi->{offset}) % $p;
			if ($pi->{offset} > $reverse_offset) {
				next;
			} elsif ($pi->{offset} == $reverse_offset) {
				$pj->{symmetric} = 1;
			} else {
				$pj->{symmetric} = 0;
			}
		} else {
			$pj->{symmetric} = 0;
		}

		my $v = $pi->{v};
		my $excess = $pi->{excess} + $pi->{stolen};
		for (my $offset = $pi->{offset}; $offset < $k; $offset += $p) {
			--$underflow;
			if (vec($v, $offset, 1)) {
				# we collided with another prime
				--$excess;
			} else {
				# we filled an empty slot
				--$needed;
				vec($v, $offset, 1) = 1;
			}
		}
		# if we found less the max, we must also reduce the excess
		$excess -= $underflow;

		# if we now have negative excess, no solution is possible
		next if $excess < 0;

		# we've managed to assign this prime without contradiction,
		# so let's try the next
		unless ($pj->{p}) {
			# oh, there are no more primes to try - do we have a solution?
			if ($needed == 0) {
				# we do: advance the index so we record it correctly
				my $oldindex = $index;
				($k, $index) = JdRecordSolution($pp, $k, $index + 1);
				if ($index > $oldindex) {
					--$pi->{offset};
					$index = $oldindex;
				}
			}
			next;
		}
		@$pj{qw{ offset v excess needed }} = (-1, $v, $excess, $needed);
		++$index;
	}

	# we failed at length k
	return $k - 1;
}

sub JdRecordSolution {
	my($pp, $k, $index) = @_;

	# we found a solution, record it
	printf(
		"[%.2f] Jd = %s [%s] floating %s\n",
		(times)[0], $k, join(
			', ', map "$pp->[$_]{p}=$pp->[$_]{offset}", 0 .. $index - 1
		), @$pp - $index,
	);

	# now try the next length
	++$k;
	$index = JdSetPP($pp, $k, $index);
	return ($k, $index);
}

sub JdSetPP {
	my($pp, $k, $index) = @_;
	my $firstp = $pp->[0]{p};
	my $excess = -$k;
	for my $i (0 .. $#$pp) {
		my $pi = $pp->[$i];
		my $p = $pi->{p};
		my $max = ceilDiv($k, $p);
		my $stolen = $i ? int($k / $p / $firstp) : 0;
		@$pi{qw{ max stolen }} = ($max, $stolen);
		$excess += $max - $stolen;
	}

	my $v = '';
	my $needed = $k;
	my $symmetric = 1;
	for my $i (0 .. $index - 1) {
		my $pi = $pp->[$i];
		@$pi{qw{ v needed excess symmetric }}
				= ($v, $needed, $excess, $symmetric);

		my $p = $pi->{p};
		$excess += $pi->{stolen};
		my $underflow = $pi->{max};
		for (my $offset = $pi->{offset}; $offset < $k; $offset += $p) {
			--$underflow;
			if (vec($v, $offset, 1)) {
				--$excess;
			} else {
				--$needed;
				vec($v, $offset, 1) = 1;
			}
		}
		$excess -= $underflow;

		if ($symmetric) {
			my $reverse_offset = ($k - 1 - $pi->{offset}) % $p;
			if ($pi->{offset} != $reverse_offset) {
				$symmetric = 0;
				if ($pi->{offset} > $reverse_offset) {
					$index = $i;
				}
			}
		}
	}
	@{ $pp->[$index] }{qw{ v needed excess symmetric }}
			= ($v, $needed, $excess, $symmetric);
	return $index;
}

=head2 JdExcess ( k, primes )

Given integer I<k> and an arrayref of distinct I<primes>, returns the
excess C< sum(ceil(k / p_i)) - k >. Since in a run of I<k> consecutive
integers at most C<ceil(k / p_i)> of them are divisible by I<p_i>, this
excess is how many collisions we can sustain (where an integer is
divisible by two or more of the I<p_i>) and still manage a complete run.

If the excess is negative, no such run is possible.

=cut

sub JdExcess {
	my($k, $sorted) = @_;
	my $excess = -$k;
	$excess += ceilDiv($k, $_) for @$sorted;
	return $excess;
}

sub ceilDiv {
	my($n, $d) = @_;
	return int(($n + $d - 1) / $d);
}

sub sortedUniquedNumbers {
	my($unsorted) = @_;
	my %unique = (map +($_ => 1), @$unsorted);
	return [ sort { $a <=> $b } keys %unique ];
}

__END__

3#: [0.00] Jd = 4 [3=0] floating 2
4#: [0.00] Jd = 6 [3=1, 5=0] floating 2
5#: [0.00] Jd = 10 [3=0, 5=2, 7=1] floating 2
6#: [0.00] Jd = 12 [3=1, 5=3, 7=2, 11=0] floating 2
7#: [0.01] Jd = 16 [3=0, 5=0, 7=4, 11=2, 13=1] floating 2
8#: [0.04] Jd = 19 [3=0, 5=1, 7=0, 11=2, 13=4] floating 3
9#: [0.06] Jd = 22 [3=0, 5=3, 7=0, 11=5, 13=4, 17=2, 19=1] floating 2
10#: [0.15] Jd = 28 [3=0, 5=1, 7=3, 11=8, 13=7, 17=5, 19=4, 23=2] floating 2
11#: [2.13] Jd = 32 [3=0, 5=1, 7=0, 11=8, 13=4, 17=5, 19=10, 23=2] floating 3
12#: [1.83] Jd = 36 [3=1, 5=0, 7=0, 11=1, 13=11, 17=9, 19=8, 23=6, 29=3, 31=2] floating 2
13#: [169.50] Jd = 44 [3=0, 5=0, 7=1, 11=4, 13=2, 17=14, 19=13, 23=11, 29=16, 31=7] floating 3
14#: [1497.03] Jd = 49 [3=0, 5=0, 7=1, 11=4, 13=2, 17=14, 19=0, 23=11, 29=17, 31=16, 37=7] floating 3
15#: [3347.31] Jd = 52 [3=0, 5=0, 7=1, 11=4, 13=2, 17=14, 19=0, 23=11, 29=17, 31=16, 37=7] floating 4
16#: [11390.65] Jd = 58 [3=0, 5=0, 7=0, 11=0, 13=0, 17=0, 19=0, 23=0, 29=8, 31=1, 37=16, 41=2, 43=4] floating 3
17#: 
