#!/opt/maths/bin/perl -w
use strict;
$| = 1;

=head1 A048669 - the Jacobsthal function

For a given n, this function yields one more than the longest possible
run of consecutive integers each sharing a factor with n.

We'll actually calculate the length of run, A048669(n)-1, and call it Jd(n).

Note that:
- we only need to know the distinct prime factors p_i of n
- if sum{ceil(k/p_i)} < k, then Jd(n) < k
- for n odd, Jd(2n) = 2Jd(n)+1

=cut

die "Usage: $0 <p1> <p2> ...\n" unless @ARGV;
my $sorted = sortedUniquedNumbers(\@ARGV);

my $t0 = (times)[0];
my $result = Jd($sorted);
my $t1 = (times)[0];

printf "[%.2f] Jd = %s\n", $t1 - $t0, $result;
exit 0;

=head2 Jd ( primes )

Given an arrayref of distinct I<primes> sorted in ascending order,
finds and returns the length of the longest possible run of consecutive
integers such that each element of the run is divisible by at least one
of the supplied primes.

The prime C<2> is special-cased, the remainder involve searching
recursively for possible assignment of the starting point of the run
mod I<p>, a prime in the list.

If there are I<k> primes (excluding C<2>), each successive length is
tried until at some length we fail to find a possible run.

=cut

sub Jd {
	my($sorted) = @_;
	return 0 if @$sorted == 0;
	return 1 if @$sorted == 1;
	my $had_2 = 0;
	if ($sorted->[0] == 2) {
		$had_2 = 1;
		shift @$sorted;
	}

	my @pp = map +{
		p => $sorted->[$_],
		remain => @$sorted - $_,
	}, 0 .. $#$sorted;

	my $best = JdFindBest(\@pp);
	return $had_2 ? 2 * $best + 1 : $best;
}

=head2 structure

{
	# fixed for the lifetime
	p => this prime,
	remain => count of primes from here to end of list

	# reset when k changes
	max => maximum copies of this prime possible for this k
	stolen => number of guaranteed collisions with first prime

	# reset on every iteration, maybe tweaked when k changes
	v => k-bit vector, bits set at each offset already hit by assigned primes
	needed => number of bits clear in v
	excess => maximum degrees of freedom

	# reset on every iteration, no tweaks
	offset => current assigned offset in run for first multiple of this prime
}

=cut

sub JdFindBest {
	my($pp) = @_;
	my $k = @$pp;	# we have a simple solution with no primes fixed

	my($best, $best_mod, $best_fixed) = ($k, [], 0);
	my $index = 0;
	@{ $pp->[0] }{qw{ offset v needed }} = (-1, '', $k);

	while (1) {
		++$k;
		JdSetPP($pp, $k, $index);

		SOLUTION: while ($index >= 0) {
			my $pi = $pp->[$index];
			my $needed = $pi->{needed};

			# break out to record solution for this $k if we have at least
			# as many unused primes as unfilled slots
			last SOLUTION if $pi->{remain} >= $needed;

			# for this prime, we want to try starting points from 0 to p-1
			my $p = $pi->{p};
			--$index, next if ++$pi->{offset} >= $p;

			# if this (and hence all remaining primes) can only appear once,
			# we have no further chance to find a solution here
			my $underflow = $pi->{max};
			--$index, next if $underflow == 1;

			my $v = $pi->{v};
			my $excess = $pi->{excess} + $pi->{stolen};
			for (my $offset = $pi->{offset}; $offset < $k; $offset += $p) {
				--$underflow;
				if (vec($v, $offset, 1)) {
					# we collided with another prime
					--$excess;
				} else {
					# we filled an empty slot
					--$needed;
					vec($v, $offset, 1) = 1;
				}
			}
			# if we found less the max, we must also reduce the excess
			$excess -= $underflow;

			# if we now have negative excess, no solution is possible
			next if $excess < 0;

			# we've managed to assign this prime without contradiction,
			# so let's try the next
			my $pj = $pp->[$index + 1];
			unless ($pj) {
				# oh, there are no more primes to try - do we have a solution?
				if ($needed > 0) {
					next SOLUTION;
				} else {
					# we do: advance the index so we record it correctly
					++$index, last SOLUTION;
				}
			}
			@$pj{qw{ offset v excess needed }} = (-1, $v, $excess, $needed);
			++$index;
		}
		last if $index < 0;
		# we found a solution, record and try longer
		$best = $k;
		$best_mod = [ map $pp->[$_]{offset}, 0 .. $index - 1 ];
		$best_fixed = $index;
		printf(
			"[%.2f] Jd = %s [%s] floating %s\n",
			(times)[0], $best,
			join(', ', map "$pp->[$_]{p}=$best_mod->[$_]", 0..$best_fixed - 1),
			@$pp - $index,
		);
		if ($index == @$pp) {
			# If we're pointing past the end of the list, we must retry
			# the last prime at the same offset.
			--$index;
			--$pp->[$index]{offset};
		}
	}

	return $best;
}

sub JdSetPP {
	my($pp, $k, $index) = @_;
	my $firstp = $pp->[0]{p};
	my $excess = -$k;
	for my $i (0 .. $#$pp) {
		my $pi = $pp->[$i];
		my $p = $pi->{p};
		my $max = ceilDiv($k, $p);
		my $stolen = $i ? int($k / $p / $firstp) : 0;
		@$pi{qw{ max stolen }} = ($max, $stolen);
		$excess += $max - $stolen;
	}

	my $v = '';
	my $needed = $k;
	for my $i (0 .. $index - 1) {
		my $pi = $pp->[$i];
		@$pi{qw{  v needed excess }} = ($v, $needed, $excess);

		my $p = $pi->{p};
		$excess += $pi->{stolen};
		my $underflow = $pi->{max};
		for (my $offset = $pi->{offset}; $offset < $k; $offset += $p) {
			--$underflow;
			if (vec($v, $offset, 1)) {
				--$excess;
			} else {
				--$needed;
				vec($v, $offset, 1) = 1;
			}
		}
		$excess -= $underflow;
	}
	@{ $pp->[$index] }{qw{  v needed excess }} = ($v, $needed, $excess);
}

=head2 JdExcess ( k, primes )

Given integer I<k> and an arrayref of distinct I<primes>, returns the
excess C< sum(ceil(k / p_i)) - k >. Since in a run of I<k> consecutive
integers at most C<ceil(k / p_i)> of them are divisible by I<p_i>, this
excess is how many collisions we can sustain (where an integer is
divisible by two or more of the I<p_i>) and still manage a complete run.

If the excess is negative, no such run is possible.

=cut

sub JdExcess {
	my($k, $sorted) = @_;
	my $excess = -$k;
	$excess += ceilDiv($k, $_) for @$sorted;
	return $excess;
}

sub ceilDiv {
	my($n, $d) = @_;
	return int(($n + $d - 1) / $d);
}

sub sortedUniquedNumbers {
	my($unsorted) = @_;
	my %unique = (map +($_ => 1), @$unsorted);
	return [ sort { $a <=> $b } keys %unique ];
}

__END__

3#: [0.00] Jd = 4 [3=0] floating 2
4#: [0.00] Jd = 6 [3=1, 5=0] floating 2
5#: [0.00] Jd = 10 [3=0, 5=2, 7=1] floating 2
6#: [0.00] Jd = 12 [3=1, 5=3, 7=2, 11=0] floating 2
7#: [0.01] Jd = 16 [3=0, 5=0, 7=4, 11=2, 13=1] floating 2
8#: [0.04] Jd = 19 [3=0, 5=1, 7=0, 11=2, 13=4] floating 3
9#: [0.06] Jd = 22 [3=0, 5=3, 7=0, 11=5, 13=4, 17=2, 19=1] floating 2
10#: [0.15] Jd = 28 [3=0, 5=1, 7=3, 11=8, 13=7, 17=5, 19=4, 23=2] floating 2
11#: [2.13] Jd = 32 [3=0, 5=1, 7=0, 11=8, 13=4, 17=5, 19=10, 23=2] floating 3
12#: [1.83] Jd = 36 [3=1, 5=0, 7=0, 11=1, 13=11, 17=9, 19=8, 23=6, 29=3, 31=2] floating 2
13#: [169.50] Jd = 44 [3=0, 5=0, 7=1, 11=4, 13=2, 17=14, 19=13, 23=11, 29=16, 31=7] floating 3
14#: [1497.03] Jd = 49 [3=0, 5=0, 7=1, 11=4, 13=2, 17=14, 19=0, 23=11, 29=17, 31=16, 37=7] floating 3
15#: [3347.31] Jd = 52 [3=0, 5=0, 7=1, 11=4, 13=2, 17=14, 19=0, 23=11, 29=17, 31=16, 37=7] floating 4
16#: [11390.65] Jd = 58 [3=0, 5=0, 7=0, 11=0, 13=0, 17=0, 19=0, 23=0, 29=8, 31=1, 37=16, 41=2, 43=4] floating 3
17#: 
