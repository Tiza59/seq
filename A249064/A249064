#!/opt/maths/bin/perl -w
use strict;
use Math::Pari qw{ nextprime factorint };
$| = 1;

=head1 A249064 (and A090252)

A249064 is the lexically first sequence of positive integers such that
each element a(n) is coprime to the next a(n) elements.

A090252 is the lexically first sequence of positive integers such that
each element a(n) is coprime to the next n elements.

Usage: run with no arguments to calculate A249064, or with "-n" to
calculate A090252.

=cut

my $A090252;
if (@ARGV && $ARGV[0] eq '-n') {
    $A090252 = 1;
}

# The sequence so far, and a bit-vector of the integers already used
my($index, $seen, @seq) = (0, '');

# The next unused prime
my $nextp = 2;

# Keep track of coprimality requirements by remembering the index at which
# suppressed prime factors become free again, and the current list of free
# prime factors (split into those smaller than sqrt($nextp) and those bigger)
my(%pend, %smallfree, %bigfree, $nextsq);

# Initialize
store_value(1, []);

while (1) {
    # Restore to the free lists any prime factors whose coprimality
    # requirement has expired
    mark_free($_) for @{ delete($pend{$index}) || [] };

	unless (find_free()) {
		# We found nothing, pick the next prime
		store_value($nextp, [ $nextp ]);
		$nextp = nextprime($nextp + 1);
        if ($nextsq && $nextp > $nextsq) {
            big_to_small();
        }
	}
}

# Move any primes from %bigfree to %smallfree that are now less than
# sqrt($nextp), and reset $nextsq to the square of the smallest remaining
# big free.
sub big_to_small {
    $nextsq = undef;
    for my $p (keys %bigfree) {
        my $sq = $p * $p;
        if ($sq > $nextp) {
            $nextsq = $sq if !$nextsq || $nextsq > $sq;
        } else {
            $smallfree{$p} = delete $bigfree{$p};
        }
    }
}

# Find a free value less than $nextp, save it and return TRUE; or return FALSE
# if there's no free value to find.
sub find_free {
    return 0 unless keys %smallfree;
    for my $n (1 .. $nextp - 1) {
        my $primes = is_free($n) or next;

        # We have a result
        store_value($n, $primes);
        return 1;
    }
    return 0;
}

# Check if the given n is free; if it is, return its arrayref of distinct
# prime factors, else return C<undef>.
sub is_free {
    my($n) = @_;

    # Skip if we've already included $n in the sequence
    return undef if vec($seen, $n, 1);

    # Simple but slow: trial division by free primes would almost
    # certainly be quicker
    my $primes = primes($n);
    for (@$primes) {
        # Skip if we're divisible by any currently suppressed prime
        return undef unless $smallfree{$_} || $bigfree{$_};
    }
    return $primes;
}

# Mark the prime factor p as free.
sub mark_free {
    my($p) = @_;
    my $sq = $p * $p;
    if ($sq < $nextp) {
        $smallfree{$p} = 1;
    } else {
        $bigfree{$p} = 1;
        if (!$nextsq || $sq < $nextsq) {
            $nextsq = $sq;
        }
    }
}

# Mark the prime factor p as no longer free.
sub mark_unfree {
    my($p) = @_;
    delete $smallfree{$p};
    delete $bigfree{$p};
    # No point resetting $nextsq
}

sub store_value {
    my($value, $primes) = @_;
    push @seq, $value;
    ++$index;
    vec($seen, $value, 1) = 1;

    # These prime factors must now be suppressed for the next a(n) terms
    # (or for the next n terms if calculating A090252).
    my $suppress = $A090252 ? $index : $value;
    push @{ $pend{$index + $suppress} }, @$primes;
    mark_unfree($_) for @$primes;

    printf "%s %s (%s)\n", $index, $value, join ' ',
            sort { $a <=> $b } keys(%smallfree), keys(%bigfree);
}

# Return an arrayref of the distinct primes dividing n
# (Some dodging required to avoid Math::Pari memory mismanagement with
# recent libpari versions.)
sub primes {
    my($n) = @_;
    my($p, $pp) = @{ factorint($n) };
    $pp = undef;
    my $r = [ map "$_", @$p ];
    $p = undef;
    return $r;
}
