#!/usr/bin/perl -w
use strict;

=head1 Number of ways of factoring n with all factors >1

To solve: does there exist n : pf(n) >= n - 1?

We represent n by abstracting its factors, so that n = 7560 = 2^4.3^3.5^2.7
is represented by the string aaaabbbccd.

The string aaab can be partitioned as a/a/a/b, a/a/ab, a/aa/b, a/aab, aa/ab,
aaa/b, aaab for 7 partitions, so pf(24) = 7. (Note that not all partitions
preserve order, eg abcd = ac/bd.)

=cut

my %seen;
my $max = 0;			# greatest pf(n) seen so far
my @pend = (['', 1]);	# start from 1, which has '' as its factor string

while (1) {
	my($s, $n) = @{ shift @pend };
	my $count = A001055($s);
	if ($count > $max) {
		my $t = mytime();
		print "$n: $count ($s) [$t]\n";
		$max = $count;
#	} else {
#		print "$n: $count ($s)\n";
	}

	# Find all ways to insert one additional factor into the string we just
	# tried; put each on the pending stack.

	# FIXME: this is slow; should fetch last char and inc that instead
	my $l = 'b';	# Will become "first unused character", to append

	# Find each location in which we can validly insert another factor:
	# if we find fggghhhi, we can insert an h iff we have more g than h.
	while ($s =~ /(.)(\1*)(?=(.)(\3*))/g) {
		if (length($4) < length($2)) {
			my $u = $s;
			substr($u, $+[0], 0) = $3;
			push @pend, [ $u, number($u) ] unless $seen{$u}++;
		}
		++$l;
	}

	# We can always append a "never seen before" character; and we can
	# always prepend an "a". (But if $s eq '', the effect is the same.)
	for ("a$s", length($s) ? "$s$l" : ()) {
		push @pend, [ $_, number($_) ] unless $seen{$_}++;
	}

	# Finally, sort the list by numeric value.
	# FIXME: this is silly, we only need the min, since we'll sort again
	# the next time round the loop. Further, if we put "a$s" before the
	# insertion loop instead of after, we'd be appending a sorted set.
	# We should just use a min-heap instead.
	@pend = sort { $a->[1] <=> $b->[1] } @pend;
}
exit 0;

# Given a string $s, return all the distinct partitionings, represented
# as ;-separated substrings. Called in scalar mode will supply just the
# count. Removal of duplicates is achieved by having the substrings
# sorted in lexical order.
# The input string must be sorted in lexical order.
sub A001055 {
	my $s = shift;
	my $t = chop $s or return wantarray ? ('') : 1;
	my @next = A001055($s);
	my %seen;
	my @new;
	# Given the single prime factor $t, and all partitions of the other factors
	for (@next) {
		# - $t can be included as a standalone factor
		my $u = join ';', sort $t, split /;/;
		push @new, $u unless $seen{$u}++;

		# - or $t can be included in any one of the other factors
		my $prev = '';
		while (/\G;?(\w+)/gc) {
			# no point including in more than one of a set of duplicate factors
			next if $1 eq $prev;
			$prev = $1;
			my $u = $_;
			# since the input string is sorted, $t is the greatest factor,
			# so appending always gives a sorted substring
			substr($u, $+[0], 0) = $t;
			$u = join ';', sort split /;/, $u;
			push @new, $u unless $seen{$u}++;
		}
	}
#print join ' ', @new, "\n";
	@new;
}

{
	# return the least integer with the given factor signature (ie the
	# element of A25487 with this signature)
	my @p; BEGIN { @p = (2, 3, 5, 7, 11, 13, 17, 19, 23) }
	my $ord_a; BEGIN { $ord_a = ord('a') }
	sub number {
		my $s = shift;
		my $p = 1;
		# No rush to check for overflow here: the numbers are used only for
		# ordering, it's the factor lists that are canonical.
		# We do not risk an ordering failure until substantially after 2^32,
		# since we will have 2^k in the mix for some relatively high k.
		$p *= $p[ord($_) - $ord_a] || die("'$_' too high")
				for split //, $s;
		$p;
	}
}

{
	my $lasttime;
	sub mytime {
		my $thistime = (times())[0];
		my $result = sprintf '%.2f', $thistime - ($lasttime || 0);
		#$lasttime = $thistime;
		return $result;
	}
}
