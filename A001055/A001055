#!/usr/bin/perl -w
use strict;
use lib 'lib';
use H::Heap;

=head1 Number of ways of factoring n with all factors >1

To solve: does there exist n : pf(n) >= n - 1?

We represent n by abstracting its factors, so that n = 7560 = 2^4.3^3.5^2.7
is represented by the string aaaabbbccd.

The string aaab can be partitioned as a/a/a/b, a/a/ab, a/aa/b, a/aab, aa/ab,
aaa/b, aaab for 7 partitions, so pf(24) = 7. (Note that not all partitions
preserve order, eg abcd = ac/bd.)

=cut

my $max = 0;			# greatest pf(n) seen so far

my $pend = H::Heap->new('$a->[1] <=> $b->[1]');
$pend->insert(['', 1]);	# start from 1, which has '' as its factor string

while (1) {
	my($s, $n) = @{ $pend->fetch or die "heap empty" };
	my $count = A001055($s);
	if ($count > $max) {
		my $t = mytime();
		print "$n: $count ($s) [$t]\n";
		$max = $count;
#	} else {
#		print "$n: $count ($s)\n";
	}

	# Record the ways we can extend the string we just tried with
	# an additional factor

	my @new;
	if (length($s) == 0) {
		push @new, 'a';
	} elsif ($s =~ /a$/) {
		push @new, ("${s}a", "${s}b");
	} else {
		my $c = substr $s, -1;
		push @new, "$s$c" if $s =~ /(?:^|(.)(?!\1))((.)\3*)((.)\5*)\z/
				&& length($2) > length($4);
		++$c;
		push @new, "$s$c";
	}

	$pend->insert([ $_, number($_) ]) for @new;
}
exit 0;

# Given a string $s, return all the distinct partitionings, represented
# as ;-separated substrings. Called in scalar mode will supply just the
# count. Removal of duplicates is achieved by having the substrings
# sorted in lexical order.
# The input string must be sorted in lexical order.
sub A001055 {
	my $s = shift;
	my $t = chop $s or return wantarray ? ('') : 1;
	my @next = A001055($s);
	my %seen;
	my @new;
	# Given the single prime factor $t, and all partitions of the other factors
	for (@next) {
		# - $t can be included as a standalone factor
		my $u = join ';', sort $t, split /;/;
		push @new, $u unless $seen{$u}++;

		# - or $t can be included in any one of the other factors
		my $prev = '';
		while (/\G;?(\w+)/gc) {
			# no point including in more than one of a set of duplicate factors
			next if $1 eq $prev;
			$prev = $1;
			my $u = $_;
			# since the input string is sorted, $t is the greatest factor,
			# so appending always gives a sorted substring
			substr($u, $+[0], 0) = $t;
			$u = join ';', sort split /;/, $u;
			push @new, $u unless $seen{$u}++;
		}
	}
#print join ' ', @new, "\n";
	@new;
}

{
	# return the least integer with the given factor signature (ie the
	# element of A25487 with this signature)
	my @p; BEGIN { @p = (2, 3, 5, 7, 11, 13, 17, 19, 23) }
	my $ord_a; BEGIN { $ord_a = ord('a') }
	sub number {
		my $s = shift;
		my $p = 1;
		# No rush to check for overflow here: the numbers are used only for
		# ordering, it's the factor lists that are canonical.
		# We do not risk an ordering failure until substantially after 2^32,
		# since we will have 2^k in the mix for some relatively high k.
		$p *= $p[ord($_) - $ord_a] || die("'$_' too high")
				for split //, $s;
		$p;
	}
}

{
	my $lasttime;
	sub mytime {
		my $thistime = (times())[0];
		my $result = sprintf '%.2f', $thistime - ($lasttime || 0);
		#$lasttime = $thistime;
		return $result;
	}
}
